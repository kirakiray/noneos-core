<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zips Test</title>
    <script src="/gh/kirakiray/ofa.js/dist/ofa.js"></script>
  </head>
  <body>
    <script src="/_sw.js" type="module"></script>
    <script type="module">
      import { test } from "/nos/ok-test/main.js";
      import { zips, unzip } from "/nos/util/zip/main.js";

      const createTextFile = (content, filename) => {
        const blob = new Blob([content], { type: "text/plain" });
        return new File([blob], filename, { type: "text/plain" });
      };

      await test("zips - Single File Compression Test", async () => {
        const files = [
          { file: createTextFile("Hello World", "hello.txt"), path: "hello.txt" }
        ];
        const zipBlob = await zips(files);

        return {
          assert: zipBlob instanceof Blob && zipBlob.size > 0,
          content: {
            message: "单个文件压缩测试",
            filesCount: 1,
            isBlob: zipBlob instanceof Blob,
            zipSize: zipBlob.size,
          },
        };
      });

      await test("zips - Multiple Files Compression Test", async () => {
        const files = [
          { file: createTextFile("Content 1", "file1.txt"), path: "file1.txt" },
          { file: createTextFile("Content 2", "file2.txt"), path: "file2.txt" },
          { file: createTextFile("Content 3", "file3.txt"), path: "file3.txt" }
        ];
        const zipBlob = await zips(files);
        const extractedFiles = await unzip(zipBlob);

        const allFilesCompressed = extractedFiles.length === 3 &&
          extractedFiles.some(f => f.path === "file1.txt") &&
          extractedFiles.some(f => f.path === "file2.txt") &&
          extractedFiles.some(f => f.path === "file3.txt");

        return {
          assert: allFilesCompressed,
          content: {
            message: "多个文件压缩测试",
            originalFilesCount: 3,
            compressedSize: zipBlob.size,
            extractedFilesCount: extractedFiles.length,
            allFilesRecovered: allFilesCompressed,
          },
        };
      });

      await test("zips - Nested Directory Compression Test", async () => {
        const files = [
          { file: createTextFile("Root File", "root.txt"), path: "root.txt" },
          { file: createTextFile("Nested File", "nested.txt"), path: "folder/nested.txt" },
          { file: createTextFile("Deep File", "deep.txt"), path: "folder/deep/deep.txt" }
        ];
        const zipBlob = await zips(files);
        const extractedFiles = await unzip(zipBlob);

        const hasNestedStructure = extractedFiles.length >= 2 &&
          extractedFiles.some(f => f.path.includes("folder"));

        return {
          assert: hasNestedStructure,
          content: {
            message: "嵌套目录压缩测试",
            originalFilesCount: 3,
            compressedSize: zipBlob.size,
            extractedFilesCount: extractedFiles.length,
            hasNestedStructure,
          },
        };
      });

      await test("zips - Empty Array Test", async () => {
        const files = [];
        const zipBlob = await zips(files);

        return {
          assert: zipBlob instanceof Blob,
          content: {
            message: "空数组压缩测试",
            isBlob: zipBlob instanceof Blob,
            zipSize: zipBlob.size,
          },
        };
      });

      await test("zips - Content Integrity Test", async () => {
        const originalContent = "Integrity test content for compression";
        const files = [
          { file: createTextFile(originalContent, "integrity.txt"), path: "integrity.txt" }
        ];
        const zipBlob = await zips(files);
        const extractedFiles = await unzip(zipBlob);
        const extractedContent = await extractedFiles[0].file.text();

        return {
          assert: extractedContent === originalContent,
          content: {
            message: "压缩内容完整性测试",
            originalContentLength: originalContent.length,
            extractedContentLength: extractedContent.length,
            contentMatch: extractedContent === originalContent,
            compressedSize: zipBlob.size,
          },
        };
      });
    </script>
  </body>
</html>
