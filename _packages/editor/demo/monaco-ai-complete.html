<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Monaco Editor - AI è‡ªåŠ¨è¡¥å…¨ (ä¿®å¤ç‰ˆ)</title>
    <style>
      #container {
        height: 600px;
        border: 1px solid #ccc;
      }
      .info {
        padding: 10px;
        background: #f0f0f0;
        margin-bottom: 10px;
        font-family: monospace;
      }
      code {
        background: #ddd;
        padding: 2px 6px;
        border-radius: 3px;
        color: #d63384;
      }
    </style>
  </head>
  <body>
    <div class="info">
      <strong>ğŸ¤– AI è‡ªåŠ¨è¡¥å…¨æ¼”ç¤ºï¼ˆä¿®å¤ç‰ˆï¼‰</strong><br />
      è¾“å…¥ <code>function</code> æˆ– <code>const</code> è§¦å‘å»ºè®®<br />
      æŒ‰ <code>Tab</code> æ¥å—ï¼Œ<code>Esc</code> å–æ¶ˆã€‚<strong
        >å·²ä¿®å¤é‡å¤é—®é¢˜ï¼</strong
      >
    </div>
    <div id="container"></div>

    <script type="module">
      import * as monaco from "https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/+esm";

      // åˆ›å»ºç¼–è¾‘å™¨
      const editor = monaco.editor.create(
        document.getElementById("container"),
        {
          language: "javascript",
          theme: "vs-dark",
          tabSize: 2,
          insertSpaces: true,
          fontSize: 14,
          automaticLayout: true,
          wordWrap: "on",
          suggest: { preview: true },
          inlineSuggest: { enabled: true },
        }
      );

      editor.setValue(`// è¾“å…¥ function æˆ– const æµ‹è¯• AI è¡¥å…¨ï¼ˆä¸ä¼šé‡å¤ï¼‰
`);

      // ==================== AI æ¨¡æ‹ŸæœåŠ¡ ====================
      const mockAICompletions = {
        function: [
          " calculateSum(a, b) {\n  return a + b;\n}",
          " handleClick(event) {\n  console.log('Clicked:', event.target);\n  $0\n}",
          " async fetchData() {\n  const response = await fetch('/api/data');\n  return response.json();\n}",
        ],
        const: [
          " result = await fetch('/api/data');\nconst data = await result.json();",
          " config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  $0\n};",
        ],
        if: [
          " (condition) {\n  // TODO: å®ç°é€»è¾‘\n  $0\n} else {\n  // å¤‡é€‰æ–¹æ¡ˆ\n}",
        ],
      };

      // é˜²æŠ–å‡½æ•°
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // è·å–å½“å‰è¾“å…¥çš„å•è¯
      function getCurrentWord(model, position) {
        const textUntilPosition = model.getValueInRange({
          startLineNumber: position.lineNumber,
          startColumn: 1,
          endLineNumber: position.lineNumber,
          endColumn: position.column,
        });
        const words = textUntilPosition.trim().split(/\s+/);
        return words[words.length - 1] || "";
      }

      // è·å–ä»£ç ä¸Šä¸‹æ–‡
      function getCodeContext(model, position, lines = 5) {
        const startLine = Math.max(1, position.lineNumber - lines);
        const endLine = Math.min(
          model.getLineCount(),
          position.lineNumber + lines
        );
        return model.getValueInRange({
          startLineNumber: startLine,
          startColumn: 1,
          endLineNumber: endLine,
          endColumn: model.getLineMaxColumn(endLine),
        });
      }

      // æ¨¡æ‹Ÿ AI API
      function simulateAIRequest(currentWord) {
        return new Promise((resolve) => {
          const delay = 100 + Math.random() * 200;
          setTimeout(() => {
            const completions = mockAICompletions[currentWord];
            if (completions && completions.length > 0) {
              resolve(
                completions[Math.floor(Math.random() * completions.length)]
              );
            } else {
              resolve(" { /* å®ç° */ }"); // é»˜è®¤è¡¥å…¨
            }
          }, delay);
        });
      }

      // ==================== ä¿®å¤æ ¸å¿ƒï¼šè¡Œå†…è¡¥å…¨æä¾›å™¨ ====================
      let lastRequestId = 0;
      let inlineCompletionsCache = null;

      monaco.languages.registerInlineCompletionsProvider("javascript", {
        provideInlineCompletions: async function (
          model,
          position,
          context,
          token
        ) {
          // 1. è·å–å½“å‰è¾“å…¥çš„å•è¯
          const currentWord = getCurrentWord(model, position);

          // 2. ä¸¥æ ¼è§¦å‘æ¡ä»¶ï¼ˆé¿å…è¯¯è§¦å‘ï¼‰
          const keywords = [
            "function",
            "const",
            "let",
            "if",
            "for",
            "class",
            "async",
          ];
          const shouldTrigger =
            keywords.includes(currentWord) &&
            !currentWord.includes("(") && // é¿å…å‡½æ•°è°ƒç”¨æ—¶è§¦å‘
            !currentWord.includes(".") && // é¿å…å¯¹è±¡å±æ€§è®¿é—®æ—¶è§¦å‘
            position.column < 30; // é¿å…é•¿è¡Œè§¦å‘

          if (!shouldTrigger) {
            return { items: [] };
          }

          const requestId = ++lastRequestId;

          try {
            // 3. è·å– AI å»ºè®®ï¼ˆä¸åŒ…å«å½“å‰å•è¯æœ¬èº«ï¼‰
            const aiSuggestion = await simulateAIRequest(currentWord);

            if (requestId !== lastRequestId) {
              return { items: [] };
            }

            // âœ… 4. å…³é”®ä¿®å¤ï¼šåˆ›å»ºé›¶å®½åº¦ rangeï¼Œé¿å…é‡å 
            const range = new monaco.Range(
              position.lineNumber,
              position.column,
              position.lineNumber,
              position.column // ä¸è¦†ç›–ä»»ä½•å·²æœ‰æ–‡æœ¬
            );

            inlineCompletionsCache = {
              items: [
                {
                  insertText: aiSuggestion,
                  range: range,
                },
              ],
            };

            return inlineCompletionsCache;
          } catch (error) {
            console.error("AI è¯·æ±‚å¤±è´¥:", error);
            return { items: [] };
          }
        },

        freeInlineCompletions: function (completions) {
          inlineCompletionsCache = null;
        },
      });

      // ==================== æ™ºèƒ½è§¦å‘æœºåˆ¶ ====================
      const debouncedTrigger = debounce(() => {
        const position = editor.getPosition();
        const model = editor.getModel();
        const currentWord = getCurrentWord(model, position);

        // ä¼˜åŒ–è§¦å‘æ¡ä»¶
        const minWordLength = 3;
        if (
          currentWord.length >= minWordLength &&
          /^(function|const|let|if|for|class|async)$/.test(currentWord)
        ) {
          editor.trigger("ai", "editor.action.inlineSuggest.trigger", {});
        }
      }, 600); // å¢åŠ é˜²æŠ–æ—¶é—´ï¼Œå‡å°‘è¯¯è§¦å‘

      editor.onDidChangeModelContent((e) => {
        // åªåœ¨ç”¨æˆ·è¾“å…¥å­—ç¬¦æ—¶è§¦å‘ï¼ˆä¸æ˜¯åˆ é™¤ï¼‰
        const isInsert = e.changes.some((change) => change.text.length > 0);
        if (isInsert) {
          debouncedTrigger();
        }
      });

      // ç»‘å®šå¿«æ·é”®
      editor.addCommand(monaco.KeyMod.Ctrl | monaco.KeyCode.Space, () => {
        editor.trigger("ai", "editor.action.inlineSuggest.trigger", {});
      });

      console.log("âœ… AI è‡ªåŠ¨è¡¥å…¨ï¼ˆä¿®å¤ç‰ˆï¼‰å·²åŠ è½½");
      console.log("ğŸ”§ ä¿®å¤å†…å®¹ï¼šæ”¹è¿› range è®¡ç®—ï¼Œé¿å…æ–‡æœ¬é‡å ");
    </script>
  </body>
</html>
