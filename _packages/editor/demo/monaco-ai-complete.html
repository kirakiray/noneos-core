<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Monaco Editor - AI Complete</title>
    <style>
      #container {
        height: 600px;
        border: 1px solid #ccc;
      }
      .info {
        padding: 10px;
        background: #f0f0f0;
        margin-bottom: 10px;
        font-family: monospace;
      }
      code {
        background: #ddd;
        padding: 2px 6px;
        border-radius: 3px;
        color: #d63384;
      }
      .warning {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
        padding: 8px;
        margin-bottom: 10px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="warning">
      <strong>âš ï¸ è¾“å…¥æ³•å…¼å®¹æ€§æç¤º</strong><br />
      ä¸ºé¿å…ç©ºæ ¼é”®å†²çªï¼Œè¯·ä½¿ç”¨ <kbd>â†’</kbd> å³ç®­å¤´é”®æ¥å—è¡¥å…¨<br />
      æˆ–ä½¿ç”¨ <code>Ctrl+Space</code> æ‰‹åŠ¨è§¦å‘ï¼Œ<code>Esc</code> å–æ¶ˆ
    </div>
    <div class="info">
      <strong>ğŸ¤– AI è‡ªåŠ¨è¡¥å…¨æ¼”ç¤ºï¼ˆç¨³å¥ç‰ˆï¼‰</strong><br />
      è¾“å…¥ <code>function</code> æˆ– <code>const</code> è§¦å‘å»ºè®®
    </div>
    <div id="container"></div>

    <script type="module">
      import * as monaco from "https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/+esm";

      // åˆ›å»ºç¼–è¾‘å™¨
      const editor = monaco.editor.create(
        document.getElementById("container"),
        {
          language: "javascript",
          theme: "vs-dark",
          tabSize: 2,
          insertSpaces: true,
          fontSize: 14,
          automaticLayout: true,
          wordWrap: "on",
          suggest: { preview: true },
          inlineSuggest: { enabled: true },
          // âœ… å…³é”®é…ç½®ï¼šé™ä½ Tab ä¼˜å…ˆçº§ï¼Œé¿å…å†²çª
          tabFocusMode: false,
        }
      );

      editor.setValue(`// è¾“å…¥ function æˆ– constï¼Œç„¶åæŒ‰ â†’ ç®­å¤´æ¥å—è¡¥å…¨
`);

      // ==================== AI æ¨¡æ‹ŸæœåŠ¡ ====================
      const mockAICompletions = {
        function: [
          " calculateSum(a, b) {\n  return a + b;\n}",
          " handleClick(event) {\n  console.log('Clicked:', event.target);\n  $0\n}",
        ],
        const: [
          " result = await fetch('/api/data');\nconst data = await result.json();",
          " config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  $0\n};",
        ],
      };

      // è·å–å½“å‰å•è¯
      function getCurrentWord(model, position) {
        const text = model.getValueInRange({
          startLineNumber: position.lineNumber,
          startColumn: 1,
          endLineNumber: position.lineNumber,
          endColumn: position.column,
        });
        return text.trim().split(/\s+/).pop() || "";
      }

      // æ¨¡æ‹Ÿ AI API
      function simulateAIRequest(currentWord) {
        return new Promise((resolve) => {
          setTimeout(() => {
            const completions = mockAICompletions[currentWord];
            resolve(
              completions
                ? completions[Math.floor(Math.random() * completions.length)]
                : " { /* å®ç° */ }"
            );
          }, 100);
        });
      }

      // ==================== ä¿®å¤æ ¸å¿ƒï¼šè¡Œå†…è¡¥å…¨æä¾›å™¨ ====================
      let lastRequestId = 0;
      let inlineCompletionsCache = null;
      let isInlineSuggestionVisible = false;

      monaco.languages.registerInlineCompletionsProvider("javascript", {
        provideInlineCompletions: async function (
          model,
          position,
          context,
          token
        ) {
          const currentWord = getCurrentWord(model, position);
          const keywords = [
            "function",
            "const",
            "let",
            "if",
            "for",
            "class",
            "async",
          ];

          // ä¸¥æ ¼è§¦å‘æ¡ä»¶
          const shouldTrigger =
            keywords.includes(currentWord) &&
            !currentWord.includes("(") &&
            position.column < 30;

          if (!shouldTrigger) {
            isInlineSuggestionVisible = false;
            return { items: [] };
          }

          const requestId = ++lastRequestId;
          try {
            const aiSuggestion = await simulateAIRequest(currentWord);
            if (requestId !== lastRequestId) return { items: [] };

            // âœ… é›¶å®½åº¦ range é¿å…é‡å 
            const range = new monaco.Range(
              position.lineNumber,
              position.column,
              position.lineNumber,
              position.column
            );

            isInlineSuggestionVisible = true;
            inlineCompletionsCache = {
              items: [{ insertText: aiSuggestion, range }],
            };
            return inlineCompletionsCache;
          } catch (error) {
            isInlineSuggestionVisible = false;
            return { items: [] };
          }
        },

        freeInlineCompletions: function (completions) {
          inlineCompletionsCache = null;
          isInlineSuggestionVisible = false;
        },
      });

      // ==================== ç¨³å¥é”®ç›˜å¤„ç† ====================
      // âœ… æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨å³ç®­å¤´æ¥å—è¡¥å…¨ï¼Œé¿å…è¾“å…¥æ³•å†²çª
      editor.onKeyDown((e) => {
        // å³ç®­å¤´é”®æ¥å—è¡¥å…¨
        if (
          e.keyCode === monaco.KeyCode.RightArrow &&
          isInlineSuggestionVisible
        ) {
          e.preventDefault();
          e.stopPropagation();
          editor.trigger("ai", "editor.action.inlineSuggest.commit", {});
          return;
        }

        // Esc å–æ¶ˆè¡¥å…¨
        if (e.keyCode === monaco.KeyCode.Escape) {
          isInlineSuggestionVisible = false;
          return;
        }

        // ç©ºæ ¼é”®ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœè¾“å…¥æ³•æ¿€æ´»ï¼Œä¸è§¦å‘æ¥å—
        if (e.keyCode === monaco.KeyCode.Space) {
          // æ£€æŸ¥æ˜¯å¦æœ‰å¯è§çš„è¡¥å…¨
          const controller = editor.getContribution(
            "editor.contrib.inlineSuggestController"
          );
          if (controller && isInlineSuggestionVisible) {
            // å»¶è¿Ÿå¤„ç†ï¼Œç­‰å¾…è¾“å…¥æ³•å®Œæˆ
            setTimeout(() => {
              if (isInlineSuggestionVisible) {
                editor.trigger("ai", "editor.action.inlineSuggest.commit", {});
              }
            }, 50);
          }
        }
      });

      // ç›‘å¬è¡¥å…¨çŠ¶æ€å˜åŒ–
      const originalSetValue = editor.setValue;
      editor.setValue = function (value) {
        isInlineSuggestionVisible = false;
        return originalSetValue.apply(this, arguments);
      };

      // é˜²æŠ–è§¦å‘
      const debouncedTrigger = debounce(() => {
        const position = editor.getPosition();
        const word = getCurrentWord(editor.getModel(), position);
        if (
          word.length >= 3 &&
          /^(function|const|let|if|for|class|async)$/.test(word)
        ) {
          editor.trigger("ai", "editor.action.inlineSuggest.trigger", {});
        }
      }, 600);

      editor.onDidChangeModelContent((e) => {
        if (e.changes.some((change) => change.text.length > 0)) {
          debouncedTrigger();
        }
      });

      // æ‰‹åŠ¨è§¦å‘å¿«æ·é”®
      editor.addCommand(monaco.KeyMod.Ctrl | monaco.KeyCode.Space, () => {
        editor.trigger("ai", "editor.action.inlineSuggest.trigger", {});
      });

      console.log("âœ… AI è‡ªåŠ¨è¡¥å…¨ï¼ˆç¨³å¥ç‰ˆï¼‰å·²åŠ è½½");
      console.log("ğŸ”§ ä¸»è¦æ”¹è¿›ï¼š");
      console.log("   â†’ å³ç®­å¤´æ¥å—è¡¥å…¨ï¼ˆé¿å…ç©ºæ ¼å†²çªï¼‰");
      console.log("   â†’ æ™ºèƒ½æ£€æµ‹è¾“å…¥æ³•çŠ¶æ€");
      console.log("   â†’ é˜²æŠ–å»¶è¿Ÿ 600ms");
    </script>
  </body>
</html>
